<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.
const int nodes = //HOLDER_NUMBER_OF_NODES
const int numEdges = //HOLDER_NUMBER_OF_EDGES
//HOLDER_NUMBER_OF_CARS
const int pid[N] = //HOLDER_CAR_PID 
const int route[N][nodes] = //HOLDER_CAR_ROUTE 
//HOLDER_NODE_POSITIONS

int timePassed[N] = //HOLDER_TIME_PASSED
int edgeTravelTime[numEdges] = //HOLDER_TRAVEL_TIME
int currentStartNode[N] = //HOLDER_CURRENT_START_NODE
typedef int[0,nodes] node_t;

//HOLDER_EDGES


int edges[numEdges][2]; //could not assign values to array when it had type double


int curr_car = 0;
int uniquetest = 0;
int edgeIds[numEdges];
int reroute[N];
int firstIntermediateNode = 46;
int horizon = 20;

typedef int[0, N-1] id_car;

chan Reroute, DoneRerouting;


int NodesToUniqueInt(int fromNode, int toNode)
{
    int x = 0;
    if (fromNode &gt;= toNode)
    {
        x = fromNode * fromNode + fromNode + toNode;
    }
    else
    {
        x = fromNode + toNode * toNode;
    }
    return x;
}

int GetEdgeId(int fromNode, int toNode)
{
    int unique = NodesToUniqueInt(fromNode, toNode);
    int i = 0;
    uniquetest = unique;
    while(i &lt; (numEdges-1) &amp;&amp; unique != edgeIds[i])
    {
        i++;
    }
    return i;
}</declaration>
	<template>
		<name x="5" y="5">Simulator</name>
		<declaration>clock x;

int connectingNodes[3] = {0,0,0};

void constructor()
{
    //initialize the edge ids
    int i;
    for(i = 0; i &lt; numEdges; i++)
    {
        edgeIds[i] = NodesToUniqueInt(networkEdges[i][0], networkEdges[i][1]);
    }
}

//check if cars have changed edge
void flow_traffic()
{
    int i = 0, j = 0;
    int currentEdge = 0;
    int timePassedCarI = 0;
    int edgeTT = 0;
    int fromNode, toNode;    


    for (i = 0; i &lt; N; i++)
    {
        timePassedCarI = timePassed[i];
        
        while(route[i][j] != currentStartNode[i] &amp;&amp; route[i][j] != -1)
        {
            j++;
        }
        fromNode = route[i][j];
        toNode = route[i][j+1];

        /*
        // ensure that the nodes are not intermediate nodes
        if(fromNode &gt;= firstIntermediateNode)
        {
            fromNode = route[i][j-1];
        }

        if(toNode &gt;= firstIntermediateNode)
        {
            toNode = route[i][j+2];
        }
        */
        edgeId = GetEdgeId(fromNode, toNode);
        
        edgeTT = edgeTravelTime[edgeId];

        if(timePassedCarI &gt;= edgeTT)
        {
            currentStartNode[i] = toNode;
            timePassed[i] = 0;
        }
        

    }
}

void get_connecting_nodes(int node)
{
    int i = 0;
    int foundNodes = 0;

    for(i = 0; i &lt; numEdges; i++)
    {
        if(networkEdges[i][0] == node)
        {
            connectingNodes[foundNodes] = networkEdges[i][1];
            foundNodes++;
        }
    }
}

int get_cars_on_edge(int edgeId)
{
    int i = 0, j = 0;
    int fromNode = 0;
    int carsOnEdge = 0;
    for(i = 0; i &lt; N; i++)
    {
        fromNode = currentStartNode[i];

        get_connecting_nodes(fromNode);

        for(j = 0; j &lt; 3; j++)
        {
            if(edgeId == GetEdgeId(fromNode, connectingNodes[j]))
            {
                carsOnEdge++;
            }
        }        
    }
    return carsOnEdge;
}


void update_weights()
{
    int i = 0;
    int carsOnEdge = 0;
    int toNode, fromNode;
    int newWeigth = 0;
    
    for(i = 0; i &lt; numEdges; i++)
    {
        carsOnEdge = get_cars_on_edge(i);
        newWeights = 0;
        //calculate weights

    }
}

void check_reroute()
{
    int i = 0, j = 0;
    int fromNode, toNode;
    int edgeId;
    int weigth;
    int threshold = 10; //TODO: find actual threshold for rerouting
    
    carsForRerouting = 0;

    for(i = 0; i &lt; N; i++)
    {
        j = 0;
        fromNode = currentStartNode[i];
        
        while(fromNode != route[i][j] &amp;&amp; route[i][j] != -1)
        {
            j++;
        }
        toNode = route[i][j+1];

        edgeId = getEdgeId(fromNode, toNode);

        weigth = edgeWeights[edgeId];

        if(weigth &gt; threshold)
        {
            reroute[i] = 1;
        }
      
    }
       
}</declaration>
		<location id="id0" x="-467" y="-127">
			<name x="-477" y="-161">Init</name>
		</location>
		<location id="id1" x="-255" y="-127">
			<urgent/>
		</location>
		<location id="id2" x="-42" y="-127">
			<urgent/>
		</location>
		<location id="id3" x="204" y="-127">
			<urgent/>
		</location>
		<location id="id4" x="442" y="-127">
			<name x="432" y="-161">End</name>
			<urgent/>
		</location>
		<location id="id5" x="85" y="59">
			<urgent/>
		</location>
		<init ref="id0"/>
		<transition controllable="false">
			<source ref="id5"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-76" y="34">DoneRerouting?</label>
			<label kind="assignment" x="-76" y="17">x++</label>
			<nail x="-119" y="59"/>
		</transition>
		<transition controllable="false">
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="guard" x="153" y="34">x &lt;= horizon</label>
			<label kind="synchronisation" x="170" y="17">Reroute!</label>
			<nail x="306" y="59"/>
		</transition>
		<transition controllable="false">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="assignment" x="280" y="-153">flow_traffic()</label>
		</transition>
		<transition controllable="false">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="assignment" x="25" y="-153">check_reroute()</label>
		</transition>
		<transition controllable="false">
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="assignment" x="-212" y="-153">update_weights()</label>
			<nail x="-59" y="-127"/>
		</transition>
		<transition controllable="false">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-399" y="-153">constructor()</label>
		</transition>
	</template>
	<template>
		<name>Rerouter</name>
		<declaration>

void choose_route(int strategy)
{
    int i = 0;
    int carRoute[nodes] = route[curr_car];
    int destNode;

    reroute[curr_car] = 0;   

    while (i &lt; (nodes-1) &amp;&amp; carRoute[i+1] != -1)
    {            
        i++;
    }

    destNode = carRoute[i]; 
    
    if(strategy == 1)
    {
        i = 0;

        
    }
    else if (strategy == 2)
    {
        //Keep current route
    }

}</declaration>
		<location id="id6" x="-909" y="-195">
		</location>
		<location id="id7" x="-714" y="-195">
		</location>
		<location id="id8" x="-510" y="-195">
		</location>
		<location id="id9" x="-314" y="-289">
		</location>
		<location id="id10" x="-314" y="-110">
		</location>
		<location id="id11" x="-110" y="-195">
		</location>
		<location id="id12" x="59" y="-195">
		</location>
		<init ref="id6"/>
		<transition controllable="false">
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="guard" x="-68" y="-221">curr_car &gt; N</label>
			<label kind="synchronisation" x="-76" y="-238">DoneRerouting!</label>
		</transition>
		<transition controllable="false">
			<source ref="id7"/>
			<target ref="id11"/>
			<label kind="guard" x="-493" y="-399">reroute[curr_car] == 0</label>
			<nail x="-714" y="-365"/>
			<nail x="-110" y="-365"/>
		</transition>
		<transition controllable="false">
			<source ref="id11"/>
			<target ref="id7"/>
			<label kind="assignment" x="-450" y="-17">curr_car++</label>
			<nail x="-110" y="-25"/>
			<nail x="-714" y="-25"/>
		</transition>
		<transition controllable="false">
			<source ref="id9"/>
			<target ref="id11"/>
		</transition>
		<transition controllable="false">
			<source ref="id10"/>
			<target ref="id11"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="assignment" x="-493" y="-136">choose_route(1)</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id9"/>
			<label kind="assignment" x="-501" y="-280">choose_route(0)</label>
		</transition>
		<transition controllable="false">
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="guard" x="-688" y="-221">reroute[curr_car] == 1</label>
		</transition>
		<transition controllable="false">
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="synchronisation" x="-841" y="-221">Reroute?</label>
		</transition>
	</template>
	<system>// Place template instantiations here.


// List one or more processes to be composed into a system.
system Simulator, Rerouter;
    </system>
	<queries>
		<query>
			<formula>E&lt;&gt; Simulator.End</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
